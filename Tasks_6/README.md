Задание:

Дан класс UserSber, модифицировать его поля не можем. Нужно написать утилитный метод: 

public static List<UserSber> findDuplicates(Collection<UserSber> collA, Collection<UserSber> collB);

который возвращает дубликаты: юзеров, которые есть в обеих коллекциях.
Одинаковыми считаем юзеров, у которых совпадают все 3 поля: username, email, passwordHash.

Требования производительности: метод findDuplicates должен работать не больше 0.2 сек. если на вход получает 2 коллекции по 100 тысяч элементов в каждой.

Рассмотреть несколько вариантов решения задачи, замерить время выполнения, вывести результат на экран.

Один из вариантов должен удовлетворять требованиям по производительности.



----------------------------------------------------------------------------------------------


Описание решения:

В работе представлены три решения.
1) Метод findDuplicates(Collection<UserSber>, Collection<UserSber>).
Создаются два объекта: set и resultSet.
В объект set добавляются элементы первой коллекции collA, благодаря чему отсекаются дубликаты, находящиеся в этой коллекции. То есть:
collA = [a1, a1, a2, a3, a3]
set = [a1, a2, a3]

После пробегаемся по каждому элементу второй коллекции collB. Если мы не можем добавить элемент этой коллекции в set (в первую коллекцию без дубликатов), значит мы нашли дубликат. Поэтому добавляем найденный дубликат в результурующее множество под названием resultSet.

2) Метод findDuplicates2(Collection<UserSber>, Collection<UserSber>).
Создаются три объекта: set, setA, setB.
setA - это коллекция collA без дубликатов, setB - это коллекция collB без дубликатов.
set - это объект, в котором хранятся элементы коллекций setA, setB.

Пусть collA = [a1, a1, a2, a3], collB = [a1, a4].
Тогда setA = [a1, a2, a3], setB = [a1, a4].
set = [a1, a2, a3, a4].

Строкой set.removeAll(setA); мы удаляем из объекта set все элементы, хранящиеся в setA.
set = [a4] после выполнения строки.

Строкой setB.removeAll(set); мы удаляем из объекта setB все элементы, хранящиеся в set.
setB = [a1]

По итогу, a1 является дубликатом в коллекциях collA и collB.

3) Метод findDuplicates3(Collection<UserSber>, Collection<UserSber>).
Пробегаемся по всем элементам в коллекции collA. Если текущий элемент есть в коллекции collB, значит мы нашли дубликат (реализовано параллельным стримом).

Результаты выполнения методов:
Тесты в классе SbersTest все методы успешно проходят (достигается проверка изменением поля CHOICE, отвечающий за то, какой именно метод необходимо проверить).

Тесты в классе SbersTestTime реализованы так:
В качестве типа объекта может выступать любая реализация интерфейса Collection. Поэтому написан метод getCollection(int), содержащий в себе три распространенных реализаций: ArrayList, LinkedList, HashSet.
Каждый тестовый метод проверяет определенный метод из класса Sbers. На любой тестовый метод дается ограничение выполнения в виде 200 ms. Тестирование метода на время проводится коллекциями, содержащими по 100 000 объектов.

Если используется ArrayList в качестве реализации Collection, то тесты выдают примерно следующий результат:
89 ms
96 ms
N ms (не справился)

Если LinkedList:
106 ms
100 ms
N ms (не справился)

Если HashSet:
60 ms
85 ms
22 ms
