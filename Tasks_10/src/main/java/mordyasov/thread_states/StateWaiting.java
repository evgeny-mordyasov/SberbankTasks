package mordyasov.thread_states;

/**
 * Класс, позволяющий смоделировать ситуацию, когда мы можем поймать поток на состояние WAITING.
 */
public class StateWaiting implements Runnable {
    @Override
    public void run() {
        doSomething();
    }

    /**
     * Первый зашедший в метод поток, блокируя монитор, пытается пробудить поток, который якобы разблокировал монитор объекта StateWaiting и ушел в состояние WAITING.
     * Напомню, что у двух поток общий объект класса StateWaiting.
     * Но т.к никакой поток еще не успел вызвать wait(), то первый поток, который только что зашел в метод, освобождает монитор и уходит в ожидание,
     * когда его пробудят.
     * Второй поток всё это время был в режиме BLOCKING. То есть, он был готов зайти в метод doSomething(), но не мог этого сделать из-за того,
     * что монитор был перехвачен другим потоком. Узнав, что монитор был осовобожден, второй поток заходит в метод, блокируя монитор.
     * Он вызывает метод notify(). В это время первый поток, который был в состоянии WAITING узнает, что его пробудили. Но свое выполнение он
     * не продолжает, потому что монитор до сих пор остается под контролем второго потока. Поэтому первый поток ожидает освобождения монитора.
     * Второй поток вызывает метод wait() и уходит в режим WAITING, освобождая монитор. Первый поток, который был пробужден notify(), узнает,
     * что монитор освободился. Поэтому он перехвает его под свой контроль и продолжает свое выполнение, вызывая второй вызов метода notify().
     * Выполнив весь метод, первый поток выходит из него, освобождая монитор, который перехватывает второй поток, тоже заканчивая выполнение метода.
     * Получается, что первый поток имел состояние WAITING, которое мы можем успеть проверить в тестовом методе.
     */
    private synchronized void doSomething() {
        try {
            notify();

            wait();

            notify();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
