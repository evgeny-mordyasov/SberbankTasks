Задание:

Вам нужно создать класс, который может выполнять тесты (по сути свой аналог junit библиотеки:)), в качестве тестов у нас также выступают классы с наборами методов над которыми есть аннотация @DoTest - но только теперь это должна быть ваша аннотация Test а не библиотечная). 


Чтобы класс мог выполнять тесты у него должен быть статический метод start(), которому в качестве параметра передается или объект типа Class, или имя класса. 

Из «класса-теста» вначале должен быть запущен метод с аннотацией @DoBeforeAll (тоже ваша аннотация) если такой имеется, далее запущены методы с аннотациями @DoTest, а по завершению всех тестов – метод с аннотацией @DoAfterAll (тоже ваша аннотация). 
Методов с аннотацией @DoTest >= 1
Методов с аннотацией @DoBeforeAll 0 или 1
Методов с аннотацией @DoAfterAll 0 или 1
Если что то не так то кидаем исключение


Сделать так, чтобы к каждому тесту можно было также добавить приоритеты (order) (int числа от 1 до N), в соответствии с которыми будет выбираться порядок их выполнения, если приоритет одинаковый то порядок не имеет значения. Методы с аннотациями @DoBeforeAll и @DoAfterAll должны присутствовать в единственном экземпляре, иначе необходимо бросить исключение при запуске «тестирования».

--------------------------------------------------------------------------------------------------------------------

Решение:

В данной лабораторной работе реализованы пользовательские аннотации @DoTest, @DoBeforeAll, @DoAfterAll, выполняющие определенную роль.
 
Модуль main:
• Три класса под аннотации:
@DoTest
@DoBeforeAll
@DoAfterAll
 
• Класс AnnotationProcessor, считывающий с класса информацию о аннотациях при наличии.
 
•Класс AnnotationException, сигнализирующий о том, что допущена ошибка в работе с аннотациями.
 
Модуль test:
• Пять классов под определенные ситуации для проверки работоспособности аннотаций:
Something, Something1, … , Something5.
 
• Класс SomethingTest, необходимый для тестирования созданных аннотаций через junit.
 
 
 
Уделю особое внимание классу AnnotationProcessor и дам кое-какие пояснения.
Статический метод runningTestMethods(Class<?>) анализирует переданный класс в качестве параметра, пытаясь понять, насколько корректно расставлены аннотации, и производит вызов методов, имеющих эти аннотации. Он использует два дополнительных метода. Перейдем сначала к ним, чтобы понять работу текущего метода.
 
Приватный статический метод methodList(Class<?>) пробегается по методам класса и ищет вышеуказанные аннотации, поставленные над методами. Как можно заметить по коду, список изначально хранит два элеменита null на позициях 0 и 1. Эти места были зарезервированы для аннотаций @DoBeforeAll и @DoAfterAll. В стриме можно увидеть, что если на 0 или 1 позициях есть null-элемент, то мы заменяем их на найденную аннотацию @DoBeforeAll или @DoAfterAll. Если мы нашли еще одну из двух указанных аннотацию и на позициях 0 или 1 уже есть не null-элемент, то мы выбрасываем ошибку AnnotationException (Число аннотаций DoBeforeAll или DoAfterAll больше 1).
 
После окончания работы стрима мы обязательно проверяем, какой размер имеет список, имеющий изначально два null-элемента. Если список по-прежнему равен 2-м (а это говорит о том, что ни одна аннотация @DoTest не была обнаружена в классе), то мы выбрасываем ошибку AnnotationException(В классе нет аннотаций DoTest).
 
По итогу из этого метода нам приходит список, содержащий методы в одном из возможных вариантов:
1) DoBeforeAll → DoTest → … → DoTest → DoAfterAll
2) DoTest → … → DoTest → DoAfterAll
3) DoBeforeAll → DoTest → … → DoTest
4) DoTest → … → DoTest
 
Проблема в том, что аннотация @DoTest имеет свойство order, которое отвечает за порядок выполнения методов. Таким образом, переходим к последнему третьему методу класса AnnotationProcessor.
 
Приватный статический метод sortingByMethodInvokeOrder(List<Method>) выполняет роль выстраивания цепочки вызовов методов в приоритетном порядке. Перед работой он отбрасывает первых два элемента списка: зарезервированные места под DoBeforeAll и DoAfterAll. Сделано для того, чтобы избежать две ситуации:
1) Обойти ошибку NullPointerException.
2) В сортировку не послать методы, аннотации (DoBeforeAll и DoAfterAll) которых не имеют свойство order.
 
Стрим, убрав первые два элемента, начинает сортировку по свойству order в порядке возрастания. Если значение order < 1, то нарушено правило о том, что значение order должно быть натуральным числом. Поэтому генерируется ошибка AnnotationException. По завершению стрима мы проверяем, какие значения первые два элемента (а этим места были заняты изначальном DoBeforeAll и DoAfterAll) в старом списке имеют. Если хоть какой-то элемент не null, то мы добавляем в список, который был отсортирован. Допустим, у нас оба элемента не равны null. Тогда DoBeforeAll будет добавлено в начало отсортированного списка, а DoAfterAll в конец. Таким образом, мы получим в верном порядке цепочку вызовов методов.
 
Перейдем к первому методу, разговор о котором прервали. Получается, что он начинает работать уже с отсортированным по свойству order списком. Он перебирает каждый метод и вызывает его, формируя список из результатов вызванных методов.
 
Вот таким образом устроена работа класса AnnotationProcessor.
 
Тестовый класс SomethingTest проверяет работу созданных аннотаций.
